from flask import Flask, request, render_template, jsonify
import os
import pefile
import pandas as pd
from sklearn.ensemble import RandomForestClassifier
import joblib

# Initialize Flask app
app = Flask(__name__)

# Load the pre-trained model (ensure you have a saved model file)
model = joblib.load('random_forest_model.pkl')  # Replace with your model path

# Feature extraction function
def extract_features(file_path):
    try:
        # Load the PE file
        pe = pefile.PE(file_path)
    except pefile.PEFormatError:
        # If it's not a valid PE file, return None
        return None
    
    # Initialize the feature dictionary
    features = {}

    # Extract available features with checks for missing attributes
    try:
        features['Machine'] = pe.FILE_HEADER.Machine
    except AttributeError:
        features['Machine'] = 0  # Use a default value like 0 or any other strategy
    
    try:
        features['NumberOfSections'] = pe.FILE_HEADER.NumberOfSections
    except AttributeError:
        features['NumberOfSections'] = 0
    
    try:
        features['TimeDateStamp'] = pe.FILE_HEADER.TimeDateStamp
    except AttributeError:
        features['TimeDateStamp'] = 0
    
    try:
        features['PointerToSymbolTable'] = pe.FILE_HEADER.PointerToSymbolTable
    except AttributeError:
        features['PointerToSymbolTable'] = 0
    
    try:
        features['NumberOfSymbols'] = pe.FILE_HEADER.NumberOfSymbols
    except AttributeError:
        features['NumberOfSymbols'] = 0
    
    try:
        features['SizeOfOptionalHeader'] = pe.FILE_HEADER.SizeOfOptionalHeader
    except AttributeError:
        features['SizeOfOptionalHeader'] = 0
    
    try:
        features['Characteristics'] = pe.FILE_HEADER.Characteristics
    except AttributeError:
        features['Characteristics'] = 0
    
    try:
        features['SizeOfCode'] = pe.FILE_HEADER.SizeOfCode
    except AttributeError:
        features['SizeOfCode'] = 0
    
    try:
        features['MajorLinkerVersion'] = pe.FILE_HEADER.MajorLinkerVersion
    except AttributeError:
        features['MajorLinkerVersion'] = 0
    
    try:
        features['MinorLinkerVersion'] = pe.FILE_HEADER.MinorLinkerVersion
    except AttributeError:
        features['MinorLinkerVersion'] = 0
    
    try:
        features['SizeOfImage'] = pe.OPTIONAL_HEADER.SizeOfImage
    except AttributeError:
        features['SizeOfImage'] = 0
    
    try:
        features['SizeOfHeaders'] = pe.OPTIONAL_HEADER.SizeOfHeaders
    except AttributeError:
        features['SizeOfHeaders'] = 0
    
    return pd.DataFrame([features])

# Prediction function
def predict_malware(file_path):
    # Extract features from the given file
    features_df = extract_features(file_path)
    
    if features_df is None:
        return None
    
    # Use the pre-trained model to make a prediction
    prediction = model.predict(features_df)
    
    # Return prediction (1 for malicious, 0 for legitimate)
    return prediction[0]

# Route for the home page
@app.route('/')
def index():
    return render_template('index.html')

# Route for file upload and prediction
@app.route('/predict', methods=['POST'])
def predict():
    if 'file' not in request.files:
        return jsonify({"error": "No file part"})
    
    file = request.files['file']
    
    if file.filename == '':
        return jsonify({"error": "No selected file"})
    
    if file and file.filename.endswith('.exe'):
        # Save the file to a temporary location
        file_path = os.path.join('uploads', file.filename)
        file.save(file_path)
        
        # Predict whether the file is malicious or legitimate
        result = predict_malware(file_path)
        
        # Clean up the uploaded file (optional)
        #os.remove(file_path)
        
        if result is None:
            return jsonify({"error": "Invalid PE file format"})
        
        # Return the result
        prediction_result = 'Malicious' if result == 1 else 'Legitimate'
        return jsonify({"prediction": prediction_result})
    
    return jsonify({"error": "Invalid file type. Please upload a .exe file."})

# Start the Flask application
if __name__ == '__main__':
    if not os.path.exists('uploads'):
        os.makedirs('uploads')
    
    app.run(debug=True)
